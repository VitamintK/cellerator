(*******************************************************************
This file was generated automatically by the Mathematica front end.
It contains Initialization cells from a Notebook file, which
typically will have the same name as this file except ending in
".nb" instead of ".m".

This file is intended to be loaded into the Mathematica kernel using
the package loading commands Get or Needs.  Doing so is equivalent
to using the Evaluate Initialization Cells menu command in the front
end.

DO NOT EDIT THIS FILE.  This entire file is regenerated
automatically each time the parent Notebook file is saved in the
Mathematica front end.  Any changes you make to this file will be
overwritten.
***********************************************************************)

























































































 BeginPackage["SBMLInvEigAnalysis`","MathSBML`", "OptimizationToolbox`ConstrainedNLP`", "OptimizationToolbox`GraphicalSolution`","OptimizationToolbox`OptimalityConditions`", "OptimizationToolbox`CommonFunctions`"] 
  
  Options[FindBistability]={
    (* Time of integration in finding initial steady-state solution*)
    Global`tEnd\[Rule]100, 
    (* Parameters not allowed to vary in the inverse algorithm *)
    Global`FixedParam\[Rule]{},  
    (* Positivity lower bound for parameters *)
    Global`ParamLowBnd\[Rule]0.00001, Global`NMax\[Rule]50,  
    Global`DisplayLevel\[Rule]2,  
    (* Stop when either eigenvalue is close enough to zero, or mis-match term becomes small*)
    Global`EigTolerance\[Rule] 10^(-3), 
    Global`AbsMisMatchTolerance\[Rule] 10^(-6),  
    Global`DoPlots->True,
    
    (* Regularization term specification *)
    Global`RegularizationStructure->{Global`mu->0.01, Global`p->0.1, Global`epsi->(0.05)^2, 
    Global`RegularizationTerm->Automatic},
    
    (* RSQP options *)
    PrintLevel\[Rule]0,
    MaxIterations\[Rule]50, SolveQPUsing\[Rule]ActiveSet,
    ConvergenceTolerance\[Rule]0.001,QPConstraintFactor\[Rule]0.95,
    MaxQPIteraions\[Rule]50, StepLengthUsing\[Rule] GoldenSectionSearch, 
    LineSearchGamma\[Rule]0.5, LineSearchDelta\[Rule] 0.1, 
    MaxLineSearchIterations\[Rule]30,ResetQPHessian\[Rule] 5 
    }
    
    Options[FindOscillations]={
    (* Time of integration in finding initial steady-state solution*)
    Global`tEnd\[Rule]100, 
    (* Parameters not allowed to vary in the inverse algorithm *)
    Global`FixedParam\[Rule]{},  
    (* Positivity lower bound for parameters *)
    Global`ParamLowBnd\[Rule]0.00001, Global`NMax\[Rule]50,  
    Global`DisplayLevel\[Rule]2,  
    (* Stop when either eigenvalue is close enough to zero, or mis-match term becomes small*)
    Global`EigTolerance\[Rule] 10^(-3), 
    Global`AbsMisMatchTolerance\[Rule] 10^(-6),  
    Global`DoPlots->True,
    
    (* Regularization term specification *)
    Global`RegularizationStructure->{Global`mu->0.01, Global`p->0.1, Global`epsi->(0.05)^2, 
    Global`RegularizationTerm->Automatic},
    
    (* RSQP options *)
    PrintLevel\[Rule]0,
    MaxIterations\[Rule]50, SolveQPUsing\[Rule]ActiveSet,
    ConvergenceTolerance\[Rule]0.001,QPConstraintFactor\[Rule]0.95,
    MaxQPIteraions\[Rule]50, StepLengthUsing\[Rule] GoldenSectionSearch, 
    LineSearchGamma\[Rule]0.5, LineSearchDelta\[Rule] 0.1, 
    MaxLineSearchIterations\[Rule]30,ResetQPHessian\[Rule] 5 
    }




SBMLInvEigAnalysis::usage = "SBMLInvEigAnalysis.m is a package that can be used to identify sparse parameter sets, whose variation from the nominal values can lead to different qualitative dynamics, such as exhibiting bistability or oscillations. The method is based on performing inverse eigenvalue analyses, placing minimal eigenvalues of the ODE system either close to the origin or lie imaginary axis. From the identified parameter solution, subsequent (forward) bifurcation analyses can verify the dynamical behaviors in an a posteriori manner."

FindBistability::usage = "FindBistability: find parameter sets that bring the system close to bistability."
FindOscillations::usage = "FindOscillations: find parameter sets that bring the system close to oscillations."



FindBistability::badpenalty = "Error: regularization term: `1` contains terms not in the parameter list of ODE model."
FindBistability::badconstraint = "Please write inequality constraints in the form g(x) \[LessEqual] 0."

FindOscillations::badpenalty = "Error: regularization term: `1` contains terms not in the parameter list of ODE model."
FindOscillations::badconstraint = "Please write inequality constraints in the form g(x) \[LessEqual] 0."







Begin["`Private`"]



 Needs["Utilities`FilterOptions`"]
  







boldBlue[x_]:= 
    StyleForm[x, FontColor\[Rule] RGBColor[0, 0, 1], FontWeight\[Rule]"Bold", 
      FontSize\[Rule] 10]; 
boldGray[x_]:= 
    StyleForm[x, FontColor\[Rule] GrayLevel[0.5], FontWeight\[Rule] "Bold"]; 
boldRed[x_]:= 
    StyleForm[x, FontColor\[Rule] RGBColor[1, 0, 0], FontWeight\[Rule]"Bold", 
      FontSize\[Rule] 10]; 
boldOrange[x_]:= 
    StyleForm[x, FontColor\[Rule] RGBColor[0.6, 0.3, 0.1], 
      FontWeight\[Rule]"Bold", FontSize\[Rule] 10]; 










FindBistability[m_, Constraints_, opts___?OptionQ]:=Module[{
 tEND, FixedParam, ParamLowBnd , NMax, DisplayLevel, n, ODES, ODESOrig, ODEVariables, 		 ModelVariables,StateVariables,StateVariablesInit, ConstantsReplaceList, RegularizationStructure},
    
    tEnd        				=Global`tEnd         		     /.{opts}/.Options[FindBistability];
    FixedParam  				=Global`FixedParam   		     /.{opts}/.Options[FindBistability];
    ParamLowBnd 				=Global`ParamLowBnd  		     /.{opts}/.Options[FindBistability];
    NMax        				=Global`NMax        		     /.{opts}/.Options[FindBistability];
    DisplayLevel                =Global`DisplayLevel             /.{opts}/.Options[FindBistability];
    EigTolerance                =Global`EigTolerance             /.{opts}/.Options[FindBistability];
    AbsMisMatchTolerance        =Global`AbsMisMatchTolerance     /.{opts}/.Options[FindBistability];        
    RegularizationStructure     =Global`RegularizationStructure  /.{opts}/.Options[FindBistability];
    DoPlots                     =Global`DoPlots                  /.{opts}/.Options[FindBistability];
               
    ODESOrig=Global`SBMLODES/.m/.FixedParam;  
    ODEVariables=Variables[Map[#[[2]]&, ODESOrig]];
  
	n=SBMLNDSolve[m, tEnd, FilterOptions[SBMLNDSolve, opts, Sequence@@Options[FindBistability]]];	
	If[DoPlots==True, SBMLPlot[n, PlotRange->All, ImageSize\[Rule] {600, 600}]];
	
	ConstantsReplaceList=Global`SBMLConstants/.m;
    ParamVariablesAll=Map[#[[1]]&,ConstantsReplaceList];
    
    (* Retain only parameters that appear in ODE, with FixedParam replaced *)  
    ParamVariables=Intersection[ParamVariablesAll, ODEVariables];
    ParamVariablesInit=ParamVariables/.ConstantsReplaceList;
    
    (* Replace positive lower bounds via transformation by squaring parameters *)
    (* Symbolic replacement rule: p_i-> ParamLowBnd + p_i^2 *)
    ParamTransformRule=Map[(#\[Rule](ParamLowBnd+(#)^2))&, ParamVariables];
    (* Replace the initial parameter values contained in ParamVariablesInit *)
    ParamTransformReplaceRule=Map[(#[[1]]\[Rule]Sqrt[Max[#[[2]]-ParamLowBnd,0]])&, Transpose[{ParamVariables, ParamVariablesInit}]];
    TransformedParamVariablesInit=Map[#[[2]]&, ParamTransformReplaceRule]; 
    Table[ If[ (Head[Constraints[[i]]]===Greater)||(Head[Constraints[[i]]]===GreaterEqual), 
        Message[FindBistability::badconstraint]; Abort[]], {i,1,Length[Constraints]}];
    
    (* Apply transformation on constraints *)
    TransformedConstraints=Map[(Apply[Head[#], {#[[1]]/.ParamTransformRule, Sqrt[Max[#[[2]]-ParamLowBnd,0]]}])&, Constraints];
    
    (* Apply transformation on ODEs *)
    ODES=ODESOrig/.ParamTransformRule;
    ODEVectorField=Map[#[[2]]&, ODES];
       
    ModelVariables=Global`SBMLModelVariables/.m;
    (* StateVariables:remove model variables that do not enter ODE *)
    StateVariables=Intersection[ModelVariables,ODEVariables];  
    StateVariablesInit=StateVariables//.Flatten[{Global`t\[Rule]tEnd, n}];
    
    Print["StateVariables:   "//boldBlue,StateVariables//boldGray];
    Print["      InitCond:   "//boldBlue,StateVariablesInit//boldGray];
    Print["ParamVariables:   "//boldBlue,ParamVariables//boldGray];
    Print["       InitVal:   "//boldBlue,ParamVariablesInit//boldGray];
    Print["Parameters fixed: "//boldBlue,FixedParam//boldGray];
    
    (* Computes analytical expression of vector field derivative df/dx *)
    JAC=Outer[D, ODEVectorField, StateVariables];
    
    AllVariables     = Join[StateVariables, ParamVariables];
    AllVariablesInit = Join[StateVariablesInit, TransformedParamVariablesInit];
    (* Initialization of iterates *)
    Sol=Map[(#[[1]]\[Rule]#[[2]])&, Transpose[{AllVariables, AllVariablesInit}]];
    
    (* Initialization of function and eigenvalue lists *)
	FuncValList={};
	MinEigList={};
	SolList={Sol};
	
	(* if Global`RegularizationTerm == Automatic *)
	PosRegTerm=
    Map[#[[1]]&,
      Position[Table[  
          ToString[RegularizationStructure[[i,1]]]=="RegularizationTerm",{i,1,Length[RegularizationStructure]}], True]];

	If[ RegularizationStructure[[ PosRegTerm[[1]],2 ]]\[Equal]Automatic, Print["Using default regularization..."//boldOrange];
		StandardLpRegTerm = Table[{ParamVariables[[i]], ParamVariablesInit[[i]], ParamVariablesInit[[i]]}, 
			{i,1,Length[ParamVariables]}];
 		   RegularizationStructure=ReplacePart[RegularizationStructure, Global`RegularizationTerm->StandardLpRegTerm,PosRegTerm]];
	
	
	If[ DisplayLevel>2, Print["Regularization:   "//boldBlue, RegularizationStructure//boldGray]];
	
	RegList=Global`RegularizationTerm/.RegularizationStructure;
	
	(* Check regularization terms *)
	NumerQRegList = Map[ NumberQ[#]&, Flatten[RegList]/.ConstantsReplaceList] ;
	Table[ If[ NumerQRegList[[i]] == False, 
       		Message[FindBistability::badpenalty, i]; Abort[] ],{i,1,Length[NumerQRegList]}];
    
    
    fPenalty=(Plus@@Map[Global`mu*((((#[[1]]-#[[2]])/#[[3]])^2+Global`epsi)^(Global`p/2)-
    Global`epsi^(Global`p/2))&,RegList])/.RegularizationStructure;
    
    If[ DisplayLevel>0, Print["Penalty term: "//boldBlue, DisplayForm[fPenalty]//boldGray]];
	
	(* Now do transformation for penalty term *)
    fPenalty=fPenalty/.ParamTransformRule;
    
    (* Check penalty parameters *)
    If[ NumerQ[fPenalty/.ConstantsReplaceList]!=True, 
    fPenalty=0.0; Print["Note: using no penalty term; possibly no "//boldRed, "mu, p, or epsi "//boldBlue, 
    "specified in RegularizationStructure"//boldRed] ];
       
    g=Flatten[ Join[Map[(#==0)&, ODEVectorField], TransformedConstraints] ];
    If[ DisplayLevel>2, Print["Transformed Constraints: "//boldBlue, g//boldGray]]; 
          
    MatrixMatch = Table[MMR[i,j] + I MMI[i,j], {i,1,Length[JAC]}, {j,1,Length[JAC]}];   
    SymErrorMatrix=MatrixMatch-JAC;   
    fMismatchSym=ComplexExpand[Re[Tr[SymErrorMatrix.ConjugateTranspose[SymErrorMatrix]]]] ;   
    (* Using StandardConstraints from OptimizationToolbox *)   
    {IneqConstraints,EqConstraints} = StandardConstraints[g]; 
    SymDerivative=Flatten[{ Outer[D,{fMismatchSym+fPenalty},    AllVariables],  
    						Outer[D, IneqConstraints,            AllVariables],  
    						Outer[D, EqConstraints,              AllVariables]}, 1];						 
              
              
    For[indexN=1, indexN\[LessEqual]NMax, indexN++,
  
    	JACNum=JAC/.Sol;
    	{matU, matT}= SchurDecomposition[JACNum, RealBlockForm\[Rule] False]//Chop;
     	matTDiag = Table[matT[[i,i]], {i,1,Length[matT]}];
	    {MinDist}=Ordering[Abs[matTDiag], 1, Less];
    	MinEigVal= matT[[MinDist,MinDist]];
    	(* Save list of minimum eigenvalues in MinEigList *)
   	 	AppendTo[MinEigList, MinEigVal];
    
    	(* now do projection *)
     	matT[[MinDist, MinDist]] =  0.0;
    	ProjJACNum=matU.(matT.ConjugateTranspose[matU]);
    	    	
    	ProjJACNumReplaceList=
    	Flatten[Join[{MapThread[(ComplexExpand[Re[#]]\[Rule] Re[#2])&, {Flatten[MatrixMatch], Flatten[ProjJACNum]} ], 
    	  	          MapThread[(ComplexExpand[Im[#]]\[Rule] Im[#2])&, {Flatten[MatrixMatch], Flatten[ProjJACNum]} ]}]];
    	   
    	fMismatch = fMismatchSym/.ProjJACNumReplaceList;
    	       	
    	If[ DisplayLevel>0, 
        	Print["#"//boldBlue,  PaddedForm[indexN,4]//boldGray, " Frob.Err.Norm: "//boldBlue,      
        	ScientificForm[PaddedForm[ fMismatch/.Sol //Chop, 7],6]//boldGray, 
        	" Penalty term: "//boldBlue, ScientificForm[PaddedForm[fPenalty/.Sol, 7],6]//boldGray,
        	" Min Eig: "//boldBlue, ScientificForm[PaddedForm[MinEigVal, 7], 6, SignPadding->True]//boldGray] ];       
        	  	
   	    f=fMismatch+fPenalty; 
   	   
   	    (* Call refined SQP optimization solver available from OptimizationToolbox`ConstrainedNLP`*)
        {{FuncVal,Sol,status},history}=RSQP[f, g, AllVariables, (AllVariables/.Sol), Gradient->(SymDerivative/.ProjJACNumReplaceList),
        FilterOptions[RSQP, opts, Sequence@@Options[FindBistability]]  ];
       
        AppendTo[FuncValList, FuncVal];
         
        EigCloseToZeroCondition=(Abs[MinEigVal]<EigTolerance);
        AbsConvergenceCondition=(Abs[fMismatch/.Sol]<AbsMisMatchTolerance);
        If[EigCloseToZeroCondition, Print["EigCloseToZeroCondition == True"//boldRed], "Num Iter = "//boldRed, indexN//boldGray];
        If[AbsConvergenceCondition, Print["AbsConvergenceCondition == True"//boldRed], "Num Iter = "//boldRed, indexN//boldGray];
        
        If[(indexN==NMax)||EigCloseToZeroCondition||AbsConvergenceCondition,  Break[]];
               
        AppendTo[SolList, Sol];
        
    ];   

     SolutionCriterion = Global`SolutionCriterion/.{opts}/.Options[FindBistability];
     Which[ SolutionCriterion=="BasedOnEigenvalues",  {OptimSolnLocation}=Ordering[Abs[MinEigList] , 1, Less];
            Print["Using criterion:  "//boldOrange, SolutionCriterion//boldGray], 
            SolutionCriterion=="BasedOnObjective"  ,  {OptimSolnLocation}=Ordering[Abs[FuncValList], 1, Less];
            Print["Using criterion:  "//boldOrange, SolutionCriterion//boldGray],
                                               True,   OptimSolnLocation = Length[SolList];
            Print["Using last iterate..."//boldOrange]                    
            ];
       
     Print["Optim solution found in iter = "//boldOrange, OptimSolnLocation//boldGray]; 
     ComputedSol       =     SolList[[OptimSolnLocation]];
     (* ReturnSol is obtained from ComputedSol by applying the transformation for positivity *)
     ReturnSol 		   =     Table[ComputedSol[[i,1]]->(ParamLowBnd+ComputedSol[[i,2]]^2), {i,1,Length[ComputedSol]}];
     
     If[DisplayLevel>1, Print["Found solution: "//boldOrange];
        	Table[Print[AllVariables[[i]]//boldGray, "->"//boldOrange, (AllVariables[[i]]/.ReturnSol)//boldGray], 
        	{i,1,Length[AllVariables]} ]
       ];
     
     ReturnFuncVal   = FuncValList[[OptimSolnLocation]];
     ReturnEigVal    =  MinEigList[[OptimSolnLocation]];
     
     ParamDiscrepancyList=Map[ Abs[(#[[1]]-#[[2]])/#[[3]]]&, RegList]/.ReturnSol;
     If[DisplayLevel>2, Print["ParamDiscrepancyList: "//boldOrange, ParamDiscrepancyList//boldGray]];
     
     ParamSelectCriterion=2*Sqrt[Global`epsi]/.RegularizationStructure;
     If[DisplayLevel>1, Print["ParamSelectCriterion: "//boldOrange, ParamSelectCriterion//boldGray]];
     
     SelectParamList=Pick[RegList, Map[(#>ParamSelectCriterion)&, ParamDiscrepancyList ]];
     If[DisplayLevel>1, Print["SelectParamList: "//boldOrange, SelectParamList//boldGray]];
     
     If[SelectParamList=={}, IdenParam={},
     	IdenParam=Map[({#[[1]], #[[2]]}\[Rule]({#[[1]], #[[2]]}/.ReturnSol))&, SelectParamList]
     ];
     
     If[DisplayLevel>1, Print["Iden Param: "//boldOrange, IdenParam//boldGray]];
     
     If[DoPlots==True,
     	ListPlot[FuncValList, PlotRange\[Rule] All, AxesOrigin\[Rule] {0,0},
  		PlotStyle\[Rule]{AbsolutePointSize[4], Hue[0.9]}, Frame\[Rule] True, 
  		ImageSize\[Rule] {600, 600}, FrameLabel\[Rule] { "Lift-and-Project Iteration", 
      	"Objective J"}];
      	
       	EigList= Transpose[ {Re[MinEigList], Im[MinEigList]} ]; 
      	EigValPlot=ListPlot[EigList, PlotRange\[Rule]All, AxesOrigin\[Rule]{0,0}, PlotStyle\[Rule]{AbsolutePointSize[4], Hue[0.7]}, 
      	Frame\[Rule] True, DisplayFunction\[Rule] Identity];

      	InitEigPlot=ListPlot[ {{Re[MinEigList[[1]]], Im[MinEigList[[1]]]}},
      	PlotRange\[Rule] All, AxesOrigin\[Rule] {0,0},
      	PlotStyle\[Rule] {AbsolutePointSize[8],Hue[0.7]}, Frame\[Rule] True, 
      	DisplayFunction\[Rule] Identity];

		Show[EigValPlot, InitEigPlot, DisplayFunction\[Rule] $DisplayFunction, 
    	FrameLabel\[Rule] { "Re[\[Lambda]]", "Im[\[Lambda]]"}, ImageSize\[Rule] {600, 600}, PlotRange\[Rule] All, 
    	PlotLabel->"Convergence history of smallest eigenvalue"];
    	];
     
	   {IdenParam, ReturnEigVal, ReturnFuncVal, ReturnSol, status} 
    ];



FindOscillations[m_, Constraints_, ImLambda_, opts___?OptionQ]:=Module[{
 tEND, FixedParam, ParamLowBnd , NMax, DisplayLevel, EigTolerance, AbsMisMatchTolerance, RegularizationStructure, DoPlots, n, ConstantsReplaceList, ODES, ODESOrig, ODEVariables,ParamVariablesAll,ParamVariables,ParamVariablesInit,ParamTransformRule, ParamTransformReplaceRule, TransformedParamVariablesInit, TransformedConstraints},
    
    tEnd        				=Global`tEnd         		     /.{opts}/.Options[FindOscillations];
    FixedParam  				=Global`FixedParam   		     /.{opts}/.Options[FindOscillations];
    ParamLowBnd 				=Global`ParamLowBnd  		     /.{opts}/.Options[FindOscillations];
    NMax        				=Global`NMax        		     /.{opts}/.Options[FindOscillations];
    DisplayLevel                =Global`DisplayLevel             /.{opts}/.Options[FindOscillations];
    EigTolerance                =Global`EigTolerance             /.{opts}/.Options[FindOscillations];
    AbsMisMatchTolerance        =Global`AbsMisMatchTolerance     /.{opts}/.Options[FindOscillations];        
    RegularizationStructure     =Global`RegularizationStructure  /.{opts}/.Options[FindOscillations];
    DoPlots                     =Global`DoPlots                  /.{opts}/.Options[FindOscillations];
               
    ODESOrig=Global`SBMLODES/.m/.FixedParam;  
    ODEVariables=Variables[Map[#[[2]]&, ODESOrig]];
  
	n=SBMLNDSolve[m, tEnd, FilterOptions[SBMLNDSolve, opts, Sequence@@Options[FindOscillations]]];	
	If[DoPlots==True, SBMLPlot[n, PlotRange->All, ImageSize\[Rule] {600, 600}]];
	
	ConstantsReplaceList=Global`SBMLConstants/.m;
    ParamVariablesAll=Map[#[[1]]&,ConstantsReplaceList];
    
    (* Retain only parameters that appear in ODE, with FixedParam replaced *)  
    ParamVariables=Intersection[ParamVariablesAll, ODEVariables];
    ParamVariablesInit=ParamVariables/.ConstantsReplaceList;
    
    (* Replace positive lower bounds via transformation by squaring parameters *)
    (* Symbolic replacement rule: p_i-> ParamLowBnd + p_i^2 *)
    ParamTransformRule=Map[(#\[Rule](ParamLowBnd+(#)^2))&, ParamVariables];
    (* Replace the initial parameter values contained in ParamVariablesInit *)
    ParamTransformReplaceRule=Map[(#[[1]]\[Rule]Sqrt[Max[#[[2]]-ParamLowBnd,0]])&, Transpose[{ParamVariables, ParamVariablesInit}]];
    TransformedParamVariablesInit=Map[#[[2]]&, ParamTransformReplaceRule]; 
    
    Table[ If[ (Head[Constraints[[i]]]===Greater)||(Head[Constraints[[i]]]===GreaterEqual), 
        Message[FindOscillations::badconstraint]; Abort[]], {i,1,Length[Constraints]}];
    
    (* Apply transformation on constraints *)
    TransformedConstraints=Map[(Apply[Head[#], {#[[1]]/.ParamTransformRule, Sqrt[Max[#[[2]]-ParamLowBnd,0]]}])&, Constraints];
    
    (* Apply transformation on ODEs *)
    ODES=ODESOrig/.ParamTransformRule;
    ODEVectorField=Map[#[[2]]&, ODES];
       
    ModelVariables=Global`SBMLModelVariables/.m;
    (* StateVariables:remove model variables that do not enter ODE *)
    StateVariables=Intersection[ModelVariables,ODEVariables];  
    StateVariablesInit=StateVariables//.Flatten[{Global`t\[Rule]tEnd, n}];
    
    Print["StateVariables:   "//boldBlue,StateVariables//boldGray];
    Print["      InitCond:   "//boldBlue,StateVariablesInit//boldGray];
    Print["ParamVariables:   "//boldBlue,ParamVariables//boldGray];
    Print["       InitVal:   "//boldBlue,ParamVariablesInit//boldGray];
    Print["Parameters fixed: "//boldBlue,FixedParam//boldGray];
    
    (* Computes analytical expression of vector field derivative df/dx *)
    JAC=Outer[D, ODEVectorField, StateVariables];
    
    AllVariables     = Join[StateVariables, ParamVariables];
    AllVariablesInit = Join[StateVariablesInit, TransformedParamVariablesInit];
    (* Initialization of iterates *)
    Sol=Map[(#[[1]]\[Rule]#[[2]])&, Transpose[{AllVariables, AllVariablesInit}]];
    
    (* Initialization of function and eigenvalue lists *)
	FuncValList={};
	MinEigList={};
	SolList={Sol};
	
	(* if Global`RegularizationTerm == Automatic *)
	PosRegTerm=
    Map[#[[1]]&,
      Position[Table[  
          ToString[RegularizationStructure[[i,1]]]=="RegularizationTerm",{i,1,Length[RegularizationStructure]}], True]];

	If[ RegularizationStructure[[ PosRegTerm[[1]],2 ]]\[Equal]Automatic, Print["Using default regularization..."//boldOrange];
		StandardLpRegTerm = Table[{ParamVariables[[i]], ParamVariablesInit[[i]], ParamVariablesInit[[i]]}, 	
		{i,1,Length[ParamVariables]}];
 		   RegularizationStructure=ReplacePart[RegularizationStructure, Global`RegularizationTerm->StandardLpRegTerm,PosRegTerm]];	
	
	If[ DisplayLevel>2, Print["Regularization:   "//boldBlue, RegularizationStructure//boldGray]];	
	RegList=Global`RegularizationTerm/.RegularizationStructure;
	
	(* Check regularization terms *)
	NumerQRegList = Map[ NumberQ[#]&, Flatten[RegList]/.ConstantsReplaceList] ;
	Table[ If[ NumerQRegList[[i]] == False, 
       		Message[FindOscillations::badpenalty, i]; Abort[] ],{i,1,Length[NumerQRegList]}];
        
    fPenalty=(Plus@@Map[Global`mu*((((#[[1]]-#[[2]])/#[[3]])^2+Global`epsi)^(Global`p/2)-
    Global`epsi^(Global`p/2))&,RegList])/.RegularizationStructure;
    
    If[ DisplayLevel>0, Print["Penalty term: "//boldBlue, DisplayForm[fPenalty]//boldGray]];
	
	(* Now do transformation for penalty term *)
    fPenalty=fPenalty/.ParamTransformRule;
    
    (* Check penalty parameters *)
    If[ NumerQ[fPenalty/.ConstantsReplaceList]!=True, 
    fPenalty=0.0; Print["Note: using no penalty term; possibly no "//boldRed, "mu, p, or epsi "//boldBlue, 
    "specified in RegularizationStructure"//boldRed] ];
           
    g=Flatten[ Join[Map[(#==0)&, ODEVectorField], TransformedConstraints] ];
    If[ DisplayLevel>2, Print["Transformed Constraints: "//boldBlue, g//boldGray]]; 
              
    MatrixMatch = Table[MMR[i,j] + I MMI[i,j], {i,1,Length[JAC]}, {j,1,Length[JAC]}];       
    SymErrorMatrix=MatrixMatch-JAC;   
    fMismatchSym=ComplexExpand[Re[Tr[SymErrorMatrix.ConjugateTranspose[SymErrorMatrix]]]] ;   
       
    {IneqConstraints,EqConstraints} = StandardConstraints[g];     
    SymDerivative=Flatten[{ Outer[D,{fMismatchSym+fPenalty},     AllVariables],  
    						Outer[D, IneqConstraints,            AllVariables],  
    						Outer[D, EqConstraints,              AllVariables]}, 1];						 

              
    For[indexN=1, indexN\[LessEqual]NMax, indexN++,
    
    	JACNum=JAC/.Sol;
    	{matU, matT}= SchurDecomposition[JACNum, RealBlockForm\[Rule] False]//Chop;
     	matTDiag = Table[matT[[i,i]], {i,1,Length[matT]}];
     	     	
     	EigProjList1 = 0+I*Max[Im[matTDiag],  Abs[ImLambda]]; 
     	EigProjList2 = 0+I*Min[Im[matTDiag], -Abs[ImLambda]]; 
     	
	 	(* MinDist1 and MinDist2 would be distinct if closest eigenvalues are conjugate pairs *)
	 	{MinDist1}=Ordering[Abs[matTDiag-EigProjList1], 1, Less];
	 	{MinDist2}=Ordering[Abs[matTDiag-EigProjList2], 1, Less];
	 	(* If they are the same, pick closest to EigProjList1 (or EigProjList2 would work the same) *)
	 	If[MinDist1==MinDist2,  {MinDist1, MinDist2}=Ordering[Abs[matTDiag-EigProjList1], 2, Less]];
	 
    	MinEigVal= {matT[[MinDist1,MinDist1]], matT[[MinDist2,MinDist2]]};
    	
    	(* Save list of minimum eigenvalues in MinEigList *)
   	 	AppendTo[MinEigList, MinEigVal];
    
    	(* now do projections to EigProjList1 and EigProjList2 *)
     	matT[[MinDist1, MinDist1]] =  EigProjList1;
     	matT[[MinDist2, MinDist2]] =  EigProjList2;
     	
    	ProjJACNum=matU.(matT.ConjugateTranspose[matU]);      	    	
    	ProjJACNumReplaceList=
    	Flatten[Join[{MapThread[(ComplexExpand[Re[#]]\[Rule] Re[#2])&, {Flatten[MatrixMatch], Flatten[ProjJACNum]} ], 
    	  	          MapThread[(ComplexExpand[Im[#]]\[Rule] Im[#2])&, {Flatten[MatrixMatch], Flatten[ProjJACNum]} ]}]];
    	    
    	fMismatch = fMismatchSym/.ProjJACNumReplaceList;
    	       	
    	If[ DisplayLevel>0, 
        	Print["#"//boldBlue,  PaddedForm[indexN,2]//boldGray, " Frob.Err.Norm:"//boldBlue,      
        	ScientificForm[PaddedForm[ fMismatch/.Sol //Chop, 3],2]//boldGray, 
        	" Penalty:"//boldBlue, ScientificForm[PaddedForm[fPenalty/.Sol, 3], 2]//boldGray,
        	" Min Eig:"//boldBlue, ScientificForm[PaddedForm[MinEigVal, 3], 2, SignPadding->True]//boldGray, "->", 
        	PaddedForm[{EigProjList1, EigProjList2}, 1]//boldGray] ];       
        	  	
   	    f=fMismatch+fPenalty; 
   	   
   	    (* Call refined SQP optimization solver available from OptimizationToolbox`ConstrainedNLP`*)
        {{FuncVal,Sol,status},history}=RSQP[f, g, AllVariables, (AllVariables/.Sol), 
        Gradient->(SymDerivative/.ProjJACNumReplaceList),
        FilterOptions[RSQP, opts, Sequence@@Options[FindOscillations]]  ];
       
        AppendTo[FuncValList, FuncVal];
         
        EigCloseToZeroCondition=(Abs[MinEigVal[[1]]]<EigTolerance)&&(Abs[MinEigVal[[2]]]<EigTolerance);
        AbsConvergenceCondition=(Abs[fMismatch/.Sol]<AbsMisMatchTolerance);
        If[EigCloseToZeroCondition, Print["EigCloseToZeroCondition == True"//boldRed], "Num Iter = "//boldRed, indexN//boldGray];
        If[AbsConvergenceCondition, Print["AbsConvergenceCondition == True"//boldRed], "Num Iter = "//boldRed, indexN//boldGray];
        
        If[(indexN==NMax)||EigCloseToZeroCondition||AbsConvergenceCondition,  Break[]];
               
        AppendTo[SolList, Sol];
        
    ];   
     
     SolutionCriterion = Global`SolutionCriterion/.{opts}/.Options[FindOscillations];
     Which[ SolutionCriterion=="BasedOnEigenvalues",  {OptimSolnLocation}=Ordering[Abs[MinEigList] , 1, Less];
            Print["Using criterion:  "//boldOrange, SolutionCriterion//boldGray], 
            SolutionCriterion=="BasedOnObjective"  ,  {OptimSolnLocation}=Ordering[Abs[FuncValList], 1, Less];
            Print["Using criterion:  "//boldOrange, SolutionCriterion//boldGray],
                                               True,   OptimSolnLocation = Length[SolList];
            Print["Using last iterate..."//boldOrange]                    
            ];       
    
     Print["Optim solution found in iter = "//boldOrange, OptimSolnLocation//boldGray]; 
     
     ComputedSol       =     SolList[[OptimSolnLocation]];
     (* ReturnSol is obtained from ComputedSol by applying the transformation for positivity *)
     ReturnSol 		   =     Table[ComputedSol[[i,1]]->(ParamLowBnd+ComputedSol[[i,2]]^2), {i,1,Length[ComputedSol]}];
     
     If[DisplayLevel>1, Print["Found solution: "//boldOrange];
        	Table[Print[AllVariables[[i]]//boldGray, "->"//boldOrange, (AllVariables[[i]]/.ReturnSol)//boldGray], 
        	{i,1,Length[AllVariables]} ]
       ];
     
     ReturnFuncVal   = FuncValList[[OptimSolnLocation]];
     ReturnEigVal    =  MinEigList[[OptimSolnLocation]];
     
     ParamDiscrepancyList=Map[ Abs[(#[[1]]-#[[2]])/#[[3]]]&, RegList]/.ReturnSol;
     If[DisplayLevel>2, Print["ParamDiscrepancyList: "//boldOrange, ParamDiscrepancyList//boldGray]];
     
     ParamSelectCriterion=2*Sqrt[Global`epsi]/.RegularizationStructure;
     If[DisplayLevel>1, Print["ParamSelectCriterion: "//boldOrange, ParamSelectCriterion//boldGray]];
     
     SelectParamList=Pick[RegList, Map[(#>ParamSelectCriterion)&, ParamDiscrepancyList ]];
     If[DisplayLevel>1, Print["SelectParamList: "//boldOrange, SelectParamList//boldGray]];
     
     If[SelectParamList=={}, IdenParam={},
     	IdenParam=Map[({#[[1]], #[[2]]}\[Rule]({#[[1]], #[[2]]}/.ReturnSol))&, SelectParamList]
     ];
     
     If[DisplayLevel>1, Print["Iden Param: "//boldOrange, IdenParam//boldGray]];
     
     If[DoPlots==True,
     	ListPlot[FuncValList, PlotRange\[Rule] All, AxesOrigin\[Rule] {0,0},
  		PlotStyle\[Rule]{AbsolutePointSize[4], Hue[0.9]}, Frame\[Rule] True, 
  		ImageSize\[Rule] {600, 600}, FrameLabel\[Rule] { "Lift-and-Project Iteration", 
      	"Objective J"}];
      	
       	EigList1= Transpose[ {Re[Transpose[MinEigList][[1]] ], Im[Transpose[MinEigList][[1]]]} ];
       	EigList2= Transpose[ {Re[Transpose[MinEigList][[2]] ], Im[Transpose[MinEigList][[2]]]} ];
       	 
      	EigValPlot1=ListPlot[EigList1, PlotRange\[Rule]All, AxesOrigin\[Rule]{0,0}, PlotStyle\[Rule]{AbsolutePointSize[4], Hue[0.7]}, 
      	Frame\[Rule] True, DisplayFunction\[Rule] Identity];

        EigValPlot2=ListPlot[EigList2, PlotRange\[Rule]All, AxesOrigin\[Rule]{0,0}, PlotStyle\[Rule]{AbsolutePointSize[4], Hue[0.4]}, 
      	Frame\[Rule] True, DisplayFunction\[Rule] Identity];

      	InitEigPlot1=ListPlot[ {{Re[MinEigList[[1,1]]], Im[MinEigList[[1,1]]]}},
      	PlotRange\[Rule] All, AxesOrigin\[Rule] {0,0},
      	PlotStyle\[Rule] {AbsolutePointSize[8],Hue[0.7]}, Frame\[Rule] True, 
      	DisplayFunction\[Rule] Identity];

      	InitEigPlot2=ListPlot[ {{Re[MinEigList[[1,2]]], Im[MinEigList[[1,2]]]}},
      	PlotRange\[Rule] All, AxesOrigin\[Rule] {0,0},
      	PlotStyle\[Rule] {AbsolutePointSize[8],Hue[0.4]}, Frame\[Rule] True, 
      	DisplayFunction\[Rule] Identity];  

		Show[EigValPlot1, EigValPlot2, InitEigPlot1, InitEigPlot2, DisplayFunction\[Rule] $DisplayFunction, 
    	FrameLabel\[Rule] { "Re[\[Lambda]]", "Im[\[Lambda]]"}, ImageSize\[Rule] {600, 600}, PlotRange\[Rule] All, 
    	PlotLabel->"Convergence history of smallest eigenvalue pair"];
    	];

     
	   {IdenParam, ReturnEigVal, ReturnFuncVal, ReturnSol, status} 
    ];







Protect[  ] 



End[ ]







Protect[FindBistability, FindOscillations] 







EndPackage[ ]



